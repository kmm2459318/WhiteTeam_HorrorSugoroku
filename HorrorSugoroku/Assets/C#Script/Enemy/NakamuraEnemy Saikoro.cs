using SmoothigTransform;
using UnityEngine;
using UnityEngine.UI;
using System.Collections;
using SmoothigTransform;

public class EnemySaikoroNakamura : MonoBehaviour
{
    [SerializeField] SmoothTransform enemySmooth;
    [SerializeField] SmoothTransform enemyBodySmooth;
    public GameObject player;
    public GameObject saikoro; // サイコロのゲームオブジェクト
    public GameObject ENorth;
    public GameObject EWest;
    public GameObject EEast;
    public GameObject ESouth;
    private bool EN = false; // 敵の東西南北
    private bool EW = false;
    private bool EE = false;
    private bool ES = false;
    public LayerMask wallLayer; // 壁のレイヤー
    public Sprite s1;
    public Sprite s2;
    public Sprite s3;
    public Sprite s4;
    public Sprite s5;
    public Sprite s6;
    private int steps; // サイコロの目の数
    private bool discovery = false;
    private bool dis = false;
    Image image;
    //public Text discoveryText; // 新しいText変数を追加
    public AudioClip discoveryBGM; // 発見時のBGM
    public AudioClip undetectedBGM; // 未発見時のBGM
    private AudioSource audioSource; // 音声再生用のAudioSource
    public AudioClip footstepSound; // 足音のAudioClip
    Vector3 goToPos = new Vector3(0, 0, 0);
    private int goToMass = 1;
    private EnemyController enemyController;
    private GameManager gameManager; // GameManagerの参照
    private EnemyLookAtPlayer enemyLookAtPlayer; // EnemyLookAtPlayerの参照
    public PlayerCloseMirror playerCloseMirror;
    public float mokushi = 3.0f;
    public int idoukagen = 1;
    public bool skill1 = false;
    public bool skill2 = false;
    private bool isTrapped = false; // トラバサミにかかっているかどうかを示すフラグ
    private bool isMoving = false; // エネミーが移動中かどうかを示すフラグ

    void Start()
    {
        // 初期化コード
        enemyController = this.GetComponent<EnemyController>();
        gameManager = FindObjectOfType<GameManager>(); // GameManagerの参照を取得
        enemyLookAtPlayer = this.GetComponent<EnemyLookAtPlayer>(); // EnemyLookAtPlayerの参照を取得

        if (enemyLookAtPlayer == null)
        {
            Debug.LogError("EnemyLookAtPlayer component is not assigned or found on the enemy object.");
        }

        if (saikoro != null)
        {
            saikoro.SetActive(false);
        }
        else
        {
            Debug.LogError("Saikoro GameObject is not assigned in the Inspector.");
        }

        // サイコロのImageを保持
        image = saikoro.GetComponent<Image>();

        // テキストの初期化
        //if (discoveryText != null)
        //{
        //    discoveryText.text = "未発見"; // 初期状態は未発見
        //}
        //else
        //{
        //    Debug.LogError("Discovery Text is not assigned in the Inspector.");
        //}

        // AudioSourceの取得
        audioSource = GetComponent<AudioSource>();
        if (audioSource == null)
        {
            audioSource = gameObject.AddComponent<AudioSource>(); // AudioSourceがなければ追加
        }
    }
    void Update()
    {
        EN = ENorth.GetComponent<PlayerNSEWCheck>().masuCheck;
        EW = EWest.GetComponent<PlayerNSEWCheck>().masuCheck;
        EE = EEast.GetComponent<PlayerNSEWCheck>().masuCheck;
        ES = ESouth.GetComponent<PlayerNSEWCheck>().masuCheck;

        if (gameManager.IsPlayerTurn())
        {
            return;
        }

        // サイコロの目に応じてスプライトを変更
        switch (steps)
        {
            case 1:
                image.sprite = s1; break;
            case 2:
                image.sprite = s2; break;
            case 3:
                image.sprite = s3; break;
            case 4:
                image.sprite = s4; break;
            case 5:
                image.sprite = s5; break;
            case 6:
                image.sprite = s6; break;
        }

        // プレイヤーが発見されたかをチェック
        if (Vector3.Distance(this.transform.position, player.transform.position) < mokushi)
        {
            //if (discoveryText != null)
            //{
            //    Debug.Log("発見！");
            //    discoveryText.text = "発見！"; // プレイヤーが近い場合、「発見！」を表示
            //}

            // 発見時のBGMを流す
            if (discoveryBGM != null && audioSource.clip != discoveryBGM)
            {
                audioSource.Stop(); // 現在のBGMを停止
                audioSource.clip = discoveryBGM;
                audioSource.Play(); // 発見時のBGMを再生
            }
            discovery = true;
            enemyLookAtPlayer.SetDiscovery(true); // エネミーの体をプレイヤーの方向に向ける

            //Debug.Log("発見！");
        }
        else
        {
            //if (discoveryText != null)
            //{
            //    discoveryText.text = "未発見"; // プレイヤーが遠い場合、「未発見」を表示
            //}

            // 未発見時のBGMを流す
            if (undetectedBGM != null && audioSource.clip != undetectedBGM)
            {
                audioSource.Stop(); // 現在のBGMを停止
                audioSource.clip = undetectedBGM;
                audioSource.Play(); // 未発見時のBGMを再生
            }
            discovery = false;
            dis = false;
            enemyLookAtPlayer.SetDiscovery(false); // エネミーの体をプレイヤーの方向に向けない

            //Debug.Log("未発見");
        }

        if (((goToPos.x + 0.1f > this.transform.position.x && goToPos.x - 0.1f < this.transform.position.x) &&
            (goToPos.z + 0.1f > this.transform.position.z && goToPos.z - 0.1f < this.transform.position.z)) || (discovery && !dis))
        {
            Debug.Log("行先変更");
            dis = true;
            GoToMassChange(goToMass);
        }
    }

    void GoToMassChange(int m)
    {
        int a;
        do
        {
            a = Random.Range(1, 5);
        } while (a == m || (a == 1 && !EE) || (a == 2 && !EN) || (a == 3 && !EW) || (a == 4 && !ES));

        switch (a)
        {
            case 1:
                goToPos += new Vector3(10f, 0, 0);
                goToMass = 3; break;
            case 2:
                goToPos += new Vector3(0, 0, 10f);
                goToMass = 4; break;
            case 3:
                goToPos += new Vector3(-10f, 0, 0);
                goToMass = 1; break;
            case 4:
                goToPos += new Vector3(0, 0, -10f);
                goToMass = 2; break;
        }
        Debug.Log(goToPos);
    }

    public IEnumerator RollEnemyDice()
    {
        bool speedidou = false;
        bool mirror = false;
        if (5 == Random.Range(1, 6) && skill1)
        {
            Debug.Log("ーーーーーー高速移動発動ーーーーーー");
            speedidou = true;
        }
        else if (5 == Random.Range(1, 6) && skill2)
        {
            Debug.Log("ーーーーーーー鏡移動発動ーーーーーーー");
            mirror = true;
            enemySmooth.PosFact = 0f;
        }

        if (!mirror)
        {
            saikoro.SetActive(true);
            for (int i = 0; i < 10; i++) // 10回ランダムに目を表示
            {
                steps = Random.Range(idoukagen, 7);
                yield return new WaitForSeconds(0.1f); // 0.1秒ごとに目を変更
            }

            if (steps <= 3)
            {
                enemySmooth.PosFact = 0.9f;
            }
            else
            {
                enemySmooth.PosFact = 0.2f;
            }

            Debug.Log("Enemy rolled: " + steps);
        }
        StartCoroutine(MoveTowardsPlayer(speedidou, mirror));
    }

    private IEnumerator MoveTowardsPlayer(bool s1, bool s2)
    {
        isMoving = true; // 移動開始
        enemyLookAtPlayer.SetIsMoving(true); // エネミーの移動状態を設定
        int initialSteps = steps;
        AudioClip currentBGM = audioSource.clip;
        bool isFootstepPlaying = false;
        Vector3 lastDire = new Vector3(0, 0, 0);
        bool s1n = false;
        GameObject mirror;
        Debug.Log(goToPos);

        if (audioSource.isPlaying)
        {
            audioSource.Pause();
        }

        enemyController.SetMovement(true); // エネミーが動き始めたらisMovingをtrueに設定

        if (!s2)
        {
            while (steps > 0)
            {
                // トラバサミにかかっている場合は移動しない
                if (isTrapped)
                {
                    Debug.Log("Enemy is trapped and cannot move.");
                    yield return new WaitForSeconds(0.5f); // 0.5秒待つだけ
                    steps = 0;
                    break;
                }

                Vector3 direction;
                if (discovery)
                {
                    direction = (player.transform.position - this.transform.position).normalized;
                    direction = GetValidDirection(direction); // 壁を避ける方向を計算
                }
                else
                {
                    direction = (goToPos - this.transform.position);
                    direction = GetValidDirection(direction);
                }

                if (direction != lastDire)
                {
                    if (direction == new Vector3(0, 0, 2.0f))
                    {
                        enemyBodySmooth.TargetRotation = Quaternion.Euler(-90, 90, 0);
                    }
                    else if (direction == new Vector3(0, 0, -2.0f))
                    {
                        enemyBodySmooth.TargetRotation = Quaternion.Euler(-90, -90, 0);
                    }
                    else if (direction == new Vector3(2.0f, 0, 0))
                    {
                        enemyBodySmooth.TargetRotation = Quaternion.Euler(-90, 180, 0);
                    }
                    else if (direction == new Vector3(-2.0f, 0, 0))
                    {
                        enemyBodySmooth.TargetRotation = Quaternion.Euler(-90, 0, 0);
                    }
                    yield return new WaitForSeconds(0.5f);
                }

                enemySmooth.TargetPosition += direction * 1.0f; // 2.0f単位で移動

                if (s1)
                {
                    if (s1n)
                    {
                        steps--;
                        s1n = false;
                    }
                    else
                    {
                        s1n = true;
                    }
                }
                else
                {
                    steps--;
                }

                // 足音が鳴っていない場合、鳴らす
                if (footstepSound != null && !isFootstepPlaying)
                {
                    audioSource.PlayOneShot(footstepSound); // 足音を鳴らす
                    isFootstepPlaying = true; // 足音再生フラグを立てる
                }

                // エネミーの移動方向を設定
                enemyLookAtPlayer.SetMoveDirection(direction);

                Debug.Log("Enemy moved towards player. Steps remaining: " + steps);

                // プレイヤーが発見されたかをチェック
                if (Vector3.Distance(this.transform.position, player.transform.position) < mokushi)
                {
                    //if (discoveryText != null)
                    //{
                    //    discoveryText.text = "発見！"; // プレイヤーが近ければ「発見！」と表示
                    //}
                    if (discoveryBGM != null && !audioSource.isPlaying) // 発見時のBGMを流す
                    {
                        audioSource.clip = discoveryBGM;
                        audioSource.Play();
                    }
                    discovery = true;
                    Debug.Log("発見！");
                }
                lastDire = direction;

                if (enemySmooth.PosFact == 0.2f)
                {
                    yield return new WaitForSeconds(0.4f); // 移動の間隔を待つ
                }
                else {
                    yield return new WaitForSeconds(1.0f);
                }
            }
            isTrapped = false;
        }
        else
        {
            Debug.Log("ミラーワーーーーーーーーーーーーープ！！！！");

            mirror = playerCloseMirror.FindClosestMirror();
            enemySmooth.TargetPosition.x = mirror.transform.position.x * 1.0f;
            enemySmooth.TargetPosition.z = mirror.transform.position.z;
            Debug.Log(mirror.transform.position);
        }

        enemyController.SetMovement(false); // エネミーの移動が終了したらisMovingをfalseに設定

        // 移動が終了したら、再度BGMを再開
        if (currentBGM != null && !audioSource.isPlaying)
        {
            audioSource.clip = currentBGM;
            audioSource.Play(); // BGMを再開
        }

        saikoro.SetActive(false); // サイコロを非表示にする

        Debug.Log("Enemy moved a total of " + initialSteps + " steps.");

        if (!gameManager.EnemyCopyOn)
        {
            FindObjectOfType<GameManager>().NextTurn(); // 次のターンに進む
        }
        else
        {
            gameManager.enemyTurnFinCount++;
        }
    }

    private Vector3 GetValidDirection(Vector3 targetDirection)
    {
        Vector3[] directions = new Vector3[]
        {
        new Vector3(2.0f, 0, 0),   // 東
        new Vector3(-2.0f, 0, 0),  // 西
        new Vector3(0, 0, 2.0f),   // 北
        new Vector3(0, 0, -2.0f)   // 南
        };

        Vector3 bestDirection = Vector3.zero;
        float closestDistance = float.MaxValue;

        foreach (Vector3 direction in directions)
        {
            Vector3 potentialPosition = this.transform.position + direction;
            if (!Physics.CheckSphere(potentialPosition, 0.5f, wallLayer))
            {
                if (discovery)
                {
                    float distanceToPlayer = Vector3.Distance(potentialPosition, player.transform.position);
                    if (distanceToPlayer < closestDistance)
                    {
                        closestDistance = distanceToPlayer;
                        bestDirection = direction;
                    }
                }
                else
                {
                    float distanceToPlayer = Vector3.Distance(potentialPosition, goToPos);
                    if (distanceToPlayer < closestDistance)
                    {
                        closestDistance = distanceToPlayer;
                        bestDirection = direction;
                    }
                }
            }
        }

        return bestDirection != Vector3.zero ? bestDirection : targetDirection; // 有効な方向があればそれを返す
    }

    public IEnumerator EnemyTurn()
    {
        yield return StartCoroutine(RollEnemyDice());
    }

    void LateUpdate()
    {
        Ray ray = new Ray(this.transform.position, this.transform.forward);
        RaycastHit hit;

        // センサー機能: Rayが何かに当たった場合にログ出力
        if (Physics.Raycast(ray, out hit, 3f)) // 3mの範囲
        {
            //Debug.Log("発見");
        }
    }

    void OnDrawGizmosSelected()
    {
        // センサーの範囲を赤い線で表示
        Gizmos.color = Color.red;
        Vector3 direction = this.transform.position + this.transform.forward * 3f;
        Gizmos.DrawLine(this.transform.position, direction);
    }

    private void OnTriggerEnter(Collider other)
    {
        //Debug.Log("敵がトラばさみに引っ掛かった！！");
        if (other.tag == ("Beartrap"))
        {
            isTrapped = true;
            Debug.Log("敵がトラばさみに引っ掛かった！！");
        }
    }
}